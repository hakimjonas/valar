name: Scala CI and Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*' # Trigger publish job on version tags
  pull_request:
    branches:
      - main

permissions:
  # Default read permission sufficient for build job's needs (checkout)
  contents: read
  # id-token needed by crazy-max/ghaction-import-gpg for provenance?
  # Let's grant it globally just in case, though may not be strictly needed by sbt publishSigned itself
  id-token: write # Added in case release plugins use OIDC

jobs:
  build:
    runs-on: ubuntu-latest
    # Need write permission for actions/upload-artifact
    permissions:
      contents: write
    outputs:
      artifact_name_base: ${{ steps.set_paths.outputs.artifact_name_base }} # Base name like valar_3-0.1.0
      scala_version_major: ${{ steps.set_paths.outputs.scala_version_major }} # Scala major version like 3

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'sbt'

      - name: Set up sbt launcher
        uses: sbt/setup-sbt@v1

      - name: Check format, lint, and run tests
        run: sbt check test

      - name: Package artifact and generate POM
        run: |
          sbt clean package makePom # package creates JAR, makePom creates target/.../pom.xml

      # Determine artifact paths and names dynamically
      - name: Set artifact paths and names
        id: set_paths
        run: |
          SCALA_VERSION_DIR=$(find target -maxdepth 1 -type d -name "scala-*" | head -n1)
          if [ -z "$SCALA_VERSION_DIR" ]; then
            echo "Error: Scala version directory not found in target!"
            exit 1
          fi
          echo "Found Scala dir: $SCALA_VERSION_DIR"

          # Use sbt-dynver to get the version for naming consistency if possible, fallback otherwise
          PROJECT_VERSION=$(sbt -Dsbt.server.forcestart=true -batch -error 'print version') || echo "0.0.0-SNAPSHOT"
          echo "Determined Project Version: $PROJECT_VERSION"

          # Look for JAR using project name and version from dynver
          # Note: Using simpler fallback directly as it worked, adjust if needed
          echo "Attempting to find JAR using fallback pattern..."
          JAR_PATH=$(find "$SCALA_VERSION_DIR" -maxdepth 1 -type f -name "valar*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -n1)

          if [ ! -f "$JAR_PATH" ]; then
            echo "Error: Main JAR artifact not found in $SCALA_VERSION_DIR using pattern 'valar*.jar'!"
            exit 1
          fi
          echo "Found JAR: $JAR_PATH"

          # Find POM file using pattern matching its generated name
          echo "Attempting to find POM using pattern..."
          POM_PATH=$(find "$SCALA_VERSION_DIR" -maxdepth 1 -type f -name "valar*.pom" | head -n1) # Use find for POM

          if [ ! -f "$POM_PATH" ]; then
            echo "Error: POM file not found in $SCALA_VERSION_DIR using pattern 'valar*.pom'! Did 'sbt makePom' run and output logs show it being written?"
            exit 1
          fi
          echo "Found POM: $POM_PATH"

          # Extract base name (e.g., valar_3-0.1.1) and Scala major version for artifact naming
          ARTIFACT_FILENAME=$(basename "$JAR_PATH" .jar)
          SCALA_MAJOR_VERSION=$(basename "$SCALA_VERSION_DIR" | sed 's/scala-//') # e.g., 3.6.4
          SCALA_MAJOR_VERSION=${SCALA_MAJOR_VERSION%%.*} # Extract major version '3'

          echo "artifact_name_base=$ARTIFACT_FILENAME" >> "$GITHUB_OUTPUT"
          echo "scala_version_major=$SCALA_MAJOR_VERSION" >> "$GITHUB_OUTPUT"

          # Prepare staging directory for upload
          mkdir -p staging
          cp "$JAR_PATH" staging/
          cp "$POM_PATH" staging/
          echo "Contents of staging:"
          ls -l staging

      - name: Upload Jar and POM for publish job
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ steps.set_paths.outputs.scala_version_major }} # Include Scala version in artifact name
          path: staging/ # Upload the contents of the staging directory
          retention-days: 1

  publish:
    # Run only when a 'v*' tag is pushed
    if: startsWith(github.ref, 'refs/tags/')
    needs: build # Wait for build job to complete
    runs-on: ubuntu-latest
    permissions:
      # Read contents for checkout
      contents: read
      # id-token needed by crazy-max/ghaction-import-gpg potentially
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch all history for sbt-dynver to determine version correctly
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'sbt'

      - name: Set up sbt launcher
        uses: sbt/setup-sbt@v1

      - name: Import GPG key
        id: import_gpg # Give step an ID
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.PGP_SECRET }}
          passphrase: ${{ secrets.PGP_PASSPHRASE }}

      # This step ensures the PGP key ID is available if needed by sbt-pgp explicitly
      # Although often sbt-pgp finds it automatically after import
      - name: Check GPG Key ID
        run: |
          echo "GPG Key ID found: ${{ steps.import_gpg.outputs.keyid }}"
      

      # Download step remains commented out - publishSigned will rebuild/repackage
      # - name: Download Jar and POM from build job
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: build-artifacts-${{ needs.build.outputs.scala_version_major }}
      #     path: target/scala-${{ needs.build.outputs.scala_version_major }}/ # Adjust path if needed

      - name: Publish to Sonatype OSSRH
        env:
          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
          SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}
          SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
        # 'publishSigned' triggers GPG signing via sbt-pgp and uploads
        # Assumes build.sbt is configured with 'publishTo' and sbt-pgp/sbt-sonatype
        # Assumes sbt-dynver provides the correct version from the tag
        run: sbt publishSigned

      # Optional: Create GitHub Release steps remain commented out
      # - name: Create GitHub Release ...
      # - name: Upload assets to GitHub Release ...