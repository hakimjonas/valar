package net.ghoula.valar
import net.ghoula.valar.ValidationResult

/** Defines a contract for observing the outcomes of validation processes.
  *
  * This typeclass provides a powerful mechanism to decouple validation logic from cross-cutting
  * concerns such as logging, metrics collection, or auditing. By implementing this trait and
  * providing it as a `given` instance, developers can seamlessly integrate Valar with external
  * monitoring and diagnostic systems.
  *
  * @see
  *   [[ValidationObserver.noOpObserver]] for the default, zero-overhead implementation that is used
  *   when no custom observer is provided.
  *
  * @example
  *   {{{ import org.slf4j.LoggerFactory
  *
  * // An example implementation that logs validation results using SLF4J. given loggingObserver:
  * ValidationObserver with { private val logger = LoggerFactory.getLogger("ValidationAnalytics")
  *
  * def onResult[A](result: ValidationResult[A]): Unit = result match { case
  * ValidationResult.Valid(_) => logger.info("Validation succeeded.") case
  * ValidationResult.Invalid(errors) => logger.warn(s"Validation failed with ${errors.size} errors:
  * ${errors.map(_.message).mkString(", ")}") } }
  *
  * // Now, any call to .observe() will automatically use the loggingObserver. val result =
  * someValidation().observe() }}}
  */
trait ValidationObserver {

  /** A callback executed for each `ValidationResult` passed to the `observe` method.
    *
    * Implementations of this method can inspect the result and trigger side-effects, such as
    * writing to a log, incrementing a metrics counter, or sending an alert. This method should not
    * throw exceptions.
    *
    * @tparam A
    *   The type of the value within the ValidationResult.
    * @param result
    *   The `ValidationResult` to be observed.
    */
  def onResult[A](result: ValidationResult[A]): Unit
}

object ValidationObserver {

  /** The default, "no-op" `ValidationObserver` that performs no action.
    *
    * This instance is provided as an `inline given`. This is a critical optimization feature. When
    * this default observer is in scope, the Scala compiler, in conjunction with the `inline`
    * `observe()` extension method, will perform full dead-code elimination.
    *
    * This ensures that the observability feature is truly zero-cost and has no performance overhead
    * unless a custom `ValidationObserver` is explicitly provided.
    */
  inline given noOpObserver: ValidationObserver with {
    def onResult[A](result: ValidationResult[A]): Unit = () // No operation
  }
}

extension [A](vr: ValidationResult[A]) {

  /** Applies the in-scope `ValidationObserver` to this `ValidationResult`.
    *
    * This extension method enables side-effecting operations on a validation result without
    * altering the flow of validation logic. It returns the original result, allowing for seamless
    * method chaining.
    *
    * This method is declared `inline` to facilitate powerful compile-time optimizations. If the
    * default [[ValidationObserver.noOpObserver]] is in scope, the compiler will eliminate this
    * entire method call from the generated bytecode.
    *
    * @param observer
    *   The `ValidationObserver` instance provided by the implicit context.
    * @return
    *   The original, unmodified `ValidationResult`, to allow for method chaining.
    * @example
    *   {{{ import net.ghoula.valar.Validator import net.ghoula.valar.ValidationResult
    *
    * def validateUsername(name: String): ValidationResult[String] = ???
    *
    * // Assuming a `given ValidationObserver` is in scope val result =
    * validateUsername("test-user") .observe() // The observer's onResult is called here
    * .map(_.toUpperCase) }}}
    */
  inline def observe()(using observer: ValidationObserver): ValidationResult[A] = {
    observer.onResult(vr)
    vr
  }
}
